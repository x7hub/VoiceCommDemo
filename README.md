VoiceCommDemo
=================

Communicate among Android devices using voice

### 发送部分

通过超声波(19.1kHz)携带信息，OOK调制，叠加一段音乐后发送。

#### 编码

此部分代码在`Codec.java`中，采用[这个Python工程](https://github.com/Katee/quietnet)的编码。

编码采用类似霍夫曼编码的思路，但是为了在接收时判断自负的开始结束，引入了对编码的限制。因为接收时通过两个连续的0判定一个自负的结束，所以要求编码首尾都是1，而且不出现连续的0。

#### 调制

此部分代码在`Modulator.java`中。

每个bit字符占用3个chunk，即重复3遍发送，这是为了在接收时方便判定同步，否则如果接收的采样区间跨越了0和1两个不同的比特，就会造成解调错误。

采用OOK调制。1bit对应有声波，声波波形采用正弦波，与采样率相关，用如下方法计算数组的值；0bit对应没有声波。

```
for (int j = 0; j < Constants.DATASIZE; j++) {
    tone[j] = Math.sin(2 * Math.PI * freq
        * ((double) (j + offset) / Constants.RATE));
}
```

调制以后如果直接发送已经可以正常接收解调了，不过这样由于声音经常发生从0跳变到很大，手机发送时会出现杂音，所以做了一个平滑处理，这也是参考了[这个Python工程](https://github.com/Katee/quietnet)，使音量平滑上升和下降，有效避免杂音。

####叠加

这部分代码在Mixer.java中。

为了让人耳直观的感受到当前有信息正在发送，所以在超声波之上叠加一段正常频率范围的音乐。经过查阅资料研究，19kHz的超声和正常频率之间不会发生担心的混频现象，所以，叠加的过程直接将两个声波的short数组按一定权值相加即可。

另外，携带信息的超声波信号可能会比背景声音更长，所以在这种情况下要扩展背景声音的长度。

### 接收部分

#### 解调

这部分代码在`Demofulator.java`中。

由AudioRecord接收到的数组按chunk的大小分片，每一片单独处理。利用FFT变换，可以计算出每一片在19kHz频率的功率，如果超过一定阈值，判定当前是1bit，如果没有超过，则当前是0bit。

符号同步问题：当在一直收到0时，认为当前还没有开始发送，一旦出现了一个超过阈值的分片，即开始发送信号，那么这个分片和后面的2个组成一个3个chunk大小的分组，他们代表的是一个bit，那么同步就完成了，再后边的分片就可以直接认为是三个一组进行判定了。

#### 解码

这部分代码在`Recognizer.java`中。

解码器中保存解调器解调得到的bit流，如果出现连续的0则认为是一个字符结束，就将之前的bit与码表中做对比，即可判定出发送方的字符。


### 发送和识别微博uid

uid发送是循环的，为了接收方判断接收到的字符串是否是完整的uid串，在发送时将uid首尾用`B`、`E`字符标明，当接收方接收到`B`字符时才开始记录，当接收到`E`时认为接收完毕，这时就可以取出中间的字符串认为是一个用户的uid，通过`sinaweibo://userinfo?uid=`这个scheme跳转到用户的profile页面。



